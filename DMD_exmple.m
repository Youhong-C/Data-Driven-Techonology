%------------------------------------------------
% Filename   : DMD_example.m
%
% Created    : 04/04/2025
%
% Purpose    : Demonstration and basic implementation 
%              of the Dynamic Mode Decomposition (DMD) 
%              algorithm for a sampled linear system.
%
% Author     : Youhong Chen
%
% Copyright  : 2025, 
%              Youhong Chen & Debraj Bhattacharjee
%------------------------------------------------

clc;            % Clear command window
clear;          % Clear workspace variables
close all;      % Close all figure windows

%% 1) Define the State-Space System
n = 4;          % Order (dimension) of the state-space system
sys = drss(n);  % Create a random discrete-time stable state-space system
sys.D = 0;      % Set the feedthrough matrix to zero for simplicity

% Check stability of the randomly generated system
if ~isstable(sys)
    error('The randomly generated system is not stable. Simulation aborted.');
end

%% 2) Simulation Setup
nStep = 100;         % Number of time steps for simulation
x0    = randn(n,1);  % Random initial state vector
xCurr = x0;          % Current state vector, updated at each iteration

% Preallocate matrices to store states
BigX = zeros(n, nStep);  % Matrix of system states (each column is a state at a given time)
BigX(:,1) = xCurr;       % Store initial state

% Random "input" sequence (not used in this example, but shown for completeness)
Gamma = randn(1, nStep-1);

% For comparison with results, store states in Z (row-wise in this code)
Z = zeros(nStep, n);      
Z(1,:) = xCurr';

%% 3) Simulate the Discrete-Time System
% Each step: xNext = A*xCurr + B*u (with u = Gamma(i-1), though not used here)

for i = 2:nStep
    u     = Gamma(i-1);          % Extract the input at time (i-1)
    xNext = sys.A*xCurr + sys.B*u*0; 
    % ^ Multiplying by zero effectively ignores input here,
    %   but the structure is kept to illustrate a typical state-space update.
    
    BigX(:,i) = xNext;           % Store the new state
    Z(i,:)    = xNext';          % Store in row-vector form for plotting
    xCurr     = xNext;           % Update current state
end

%% 4) Perform DMD on the Simulated Data
% BigX contains columns of state snapshots. The user must provide a 
% DMD_Truncated function or adapt it to their environment.

[A_tilde, dmd_modes, dmd_amplitudes, dmd_evals, dmd_evecs, U] = DMD_Truncated(BigX);

%% 5) Compare Eigenvalues of the True System vs. the DMD-Identified System
disp('Eigenvalues of the original system matrix A:');
disp(eig(sys.A));

disp('Eigenvalues of the identified system matrix A_tilde:');
disp(eig(A_tilde));

%% 6) Compare System Responses
% Compare the response generated by A_tilde with the response generated 
% by reconstructing the state as (dmd_evecs * dmd_evals / dmd_evecs) * x.

xRoute1 = zeros(n, nStep);   % Response using A_tilde directly
xRoute2 = zeros(n, nStep);   % Response using the DMD eigen decomposition
xRoute1(:,1) = x0;
xRoute2(:,1) = x0;

% Response 1: x_{k+1} = A_tilde * x_k
xCurr = x0;
for i = 2:nStep
    xNext = A_tilde * xCurr;
    xRoute1(:,i) = xNext;
    xCurr = xNext;
end

% Response 2: x_{k+1} = (dmd_evecs * dmd_evals / dmd_evecs) * x_k
% This is essentially x_{k+1} = V * Lambda * V^{-1} * x_k,
% which should be (approximately) the same as using A_tilde directly.
xCurr = x0;
for i = 2:nStep
    xNext = (dmd_evecs * dmd_evals / dmd_evecs) * xCurr;
    xRoute2(:,i) = xNext;
    xCurr = xNext;
end

% Compute element-wise absolute differences for xRoute1 and xRoute2
xError = abs(xRoute1) - abs(xRoute2);

%% 7) Verification by Error Matrix
% Compare Y = X_{k+1} to A_tilde * X_k to see how close the DMD model 
% approximates the original state map.

Y = BigX(:,2:end);          % All columns except the first (i.e., x2..xN)
X = BigX(:,1:end-1);        % All columns except the last (i.e., x1..xN-1)
errorMatrix = Y - A_tilde*X;

%% 8) Examine Eigenvectors of the Original vs. the Identified System
[V_system, ~] = eig(sys.A);    % Eigenvectors of the true system
[V_DMD, ~]    = eig(A_tilde);  % Eigenvectors of the DMD-identified system

%% 9) (Optional) Reconstruct the Original A Matrix
% If the user has a known transformation T, it might be used to 
% reconstruct A in a transformed basis. "T" is not defined in this code 
% but is shown here for illustration.

% T = <some transform>; % The user must define T if needed.
% A_Reconstructed = T * A_tilde * inv(T);

% disp('Difference between the original A and the reconstructed A:');
% disp(sys.A - A_Reconstructed);
% [V_Reconstructed, ~] = eig(A_Reconstructed);

%% 10) Reproduction of State Trajectories via DMD
% This demonstrates how to project the initial state onto the DMD 
% eigenbasis and reproduce the time evolution.

time = 1:nStep;                  % Time vector for plotting
x_project = zeros(n, length(time));
x_project(:,1) = x0;

% Extract necessary terms for the DMD-based propagation
Phi   = U * dmd_evecs;           % Full-state eigenvectors from truncated SVD + DMD
Lambda = dmd_evals;              % DMD eigenvalues

% (a) Projected solution: x(k) = Phi * Lambda^(k-1) * Phi^{-1} * x0
for k = 2:nStep
    x_project(:,k) = Phi * (Lambda^(k-1)) * (Phi \ x0);
end

% (b) Exactly the same concept but using the DMD modes directly
x_exact = zeros(n, length(time));
x_exact(:,1) = x0;
for k = 2:nStep
    x_exact(:,k) = dmd_modes * (Lambda^(k-1)) * (dmd_modes \ x0);
end

%% 11) Plot the Results for Comparison
figure;
hold on;
% Projected data using Phi
plot(time, x_project(1,:), '--', 'LineWidth', 5, ...
     'DisplayName', 'x_1(t) (DMD projected)');
plot(time, x_project(2,:), '--', 'LineWidth', 5, ...
     'DisplayName', 'x_2(t) (DMD projected)');

% Exact data using dmd_modes
plot(time, x_exact(1,:), ':', 'LineWidth', 3, ...
     'DisplayName', 'x_1(t) (DMD exact)');
plot(time, x_exact(2,:), ':', 'LineWidth', 3, ...
     'DisplayName', 'x_2(t) (DMD exact)');

% Original data from simulation
plot(time, Z(:,1), '-', 'LineWidth', 1, ...
     'DisplayName', 'x_1(t) (original)');
plot(time, Z(:,2), '-', 'LineWidth', 1, ...
     'DisplayName', 'x_2(t) (original)');

hold off;
grid on;
xlabel('Time Step');
ylabel('State Variables');
legend show;
title('Comparison of State Evolutions: Original vs. DMD');
